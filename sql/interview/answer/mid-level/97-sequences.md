# 97. What are sequences?

## Definition

A sequence in PostgreSQL is a database object that generates a sequence of unique numeric values. Sequences are commonly used to generate primary key values, ensuring each row gets a unique identifier. They are atomic, thread-safe, and guarantee uniqueness even in concurrent environments.

## Basic Concepts

Sequences provide:
- **Automatic number generation** for primary keys and unique identifiers
- **Concurrency safety** - multiple connections can safely get unique values
- **Customizable increment patterns** (step, start value, min/max values)
- **Atomic operations** - getting the next value is guaranteed to be unique

## Creating Sequences

### Basic Sequence Creation

```sql
-- Simple sequence
CREATE SEQUENCE my_sequence;

-- Get next value
SELECT nextval('my_sequence'); -- Returns 1
SELECT nextval('my_sequence'); -- Returns 2
SELECT nextval('my_sequence'); -- Returns 3

-- Check current value
SELECT currval('my_sequence'); -- Returns 3 (last value from current session)

-- Peek at next value without consuming it
SELECT last_value FROM my_sequence; -- Returns 3
```

### Sequence with Custom Parameters

```sql
-- Create sequence with custom settings
CREATE SEQUENCE order_number_seq
    START WITH 1000        -- Start at 1000
    INCREMENT BY 1         -- Increment by 1 (default)
    MINVALUE 1000         -- Minimum value
    MAXVALUE 999999       -- Maximum value
    CACHE 50              -- Cache 50 values for performance
    CYCLE;                -- Restart at MINVALUE when MAXVALUE is reached

-- Alternative syntax
CREATE SEQUENCE invoice_seq
    AS INTEGER            -- Data type (BIGINT is default)
    START 10000
    INCREMENT 5
    NO CYCLE;             -- Don't cycle (default)
```

### Sequence Options Explained

```sql
CREATE SEQUENCE example_seq
    AS BIGINT                    -- Data type: SMALLINT, INTEGER, BIGINT
    START WITH 100               -- Starting value
    INCREMENT BY 2               -- Step size (can be negative)
    MINVALUE 1                   -- Minimum value
    MAXVALUE 9223372036854775807 -- Maximum value
    CACHE 1                      -- Number of values to cache (1 = no cache)
    CYCLE                        -- Restart when limit reached
    OWNED BY table_name.column_name; -- Auto-drop when table/column is dropped
```

## Using Sequences

### Basic Sequence Operations

```sql
-- Create a sequence
CREATE SEQUENCE user_id_seq START 1;

-- Get next value
SELECT nextval('user_id_seq'); -- 1

-- Get current value (only after nextval in same session)
SELECT currval('user_id_seq'); -- 1

-- Set sequence to specific value
SELECT setval('user_id_seq', 100); -- Sets to 100, next nextval() returns 101
SELECT setval('user_id_seq', 200, false); -- Sets to 200, next nextval() returns 200

-- Get last value without affecting sequence
SELECT last_value FROM user_id_seq;
```

### Sequences with Tables

```sql
-- Method 1: Manual sequence usage
CREATE SEQUENCE customer_id_seq;

CREATE TABLE customers (
    id INTEGER DEFAULT nextval('customer_id_seq') PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(100) UNIQUE
);

-- Make sequence owned by the column (auto-drop with table)
ALTER SEQUENCE customer_id_seq OWNED BY customers.id;

-- Insert data (id is auto-generated)
INSERT INTO customers (name, email) 
VALUES ('John Doe', 'john@example.com');

-- Method 2: SERIAL shorthand (creates sequence automatically)
CREATE TABLE products (
    id SERIAL PRIMARY KEY,              -- Creates product_id_seq automatically
    name VARCHAR(200) NOT NULL,
    price DECIMAL(10,2)
);

-- Method 3: IDENTITY columns (PostgreSQL 10+)
CREATE TABLE orders (
    id INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    customer_id INTEGER,
    order_date DATE DEFAULT CURRENT_DATE
);

-- Or with options
CREATE TABLE invoices (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY (
        START WITH 1000 
        INCREMENT BY 1
    ) PRIMARY KEY,
    amount DECIMAL(10,2)
);
```

## Advanced Sequence Examples

### Example 1: Order Number Generation

```sql
-- Create sequence for order numbers
CREATE SEQUENCE order_number_seq
    START WITH 100001
    INCREMENT BY 1
    MINVALUE 100001
    MAXVALUE 999999
    CACHE 10
    NO CYCLE;

-- Create orders table
CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    order_number VARCHAR(10) DEFAULT 'ORD' || lpad(nextval('order_number_seq')::TEXT, 6, '0'),
    customer_id INTEGER NOT NULL,
    order_date DATE DEFAULT CURRENT_DATE,
    total_amount DECIMAL(10,2),
    status VARCHAR(20) DEFAULT 'pending'
);

-- Insert orders
INSERT INTO orders (customer_id, total_amount) 
VALUES (1, 299.99), (2, 150.00);

-- View results
SELECT id, order_number, customer_id, total_amount FROM orders;
-- Results:
-- id | order_number | customer_id | total_amount
--  1 | ORD100001    |           1 |       299.99
--  2 | ORD100002    |           2 |       150.00
```

### Example 2: Multi-Format ID Generation

```sql
-- Sequences for different entity types
CREATE SEQUENCE customer_seq START 1001;
CREATE SEQUENCE product_seq START 2001;
CREATE SEQUENCE vendor_seq START 3001;

-- Function to generate formatted IDs
CREATE OR REPLACE FUNCTION generate_customer_id()
RETURNS VARCHAR(10) AS $$
BEGIN
    RETURN 'CUST' || lpad(nextval('customer_seq')::TEXT, 6, '0');
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION generate_product_id()
RETURNS VARCHAR(10) AS $$
BEGIN
    RETURN 'PROD' || lpad(nextval('product_seq')::TEXT, 6, '0');
END;
$$ LANGUAGE plpgsql;

-- Tables using custom ID generators
CREATE TABLE customers (
    customer_id VARCHAR(10) DEFAULT generate_customer_id() PRIMARY KEY,
    company_name VARCHAR(200) NOT NULL,
    contact_email VARCHAR(100)
);

CREATE TABLE products (
    product_id VARCHAR(10) DEFAULT generate_product_id() PRIMARY KEY,
    product_name VARCHAR(200) NOT NULL,
    category VARCHAR(100)
);

-- Insert data
INSERT INTO customers (company_name, contact_email) 
VALUES ('Acme Corp', 'contact@acme.com');

INSERT INTO products (product_name, category) 
VALUES ('Widget A', 'Electronics');

-- View results
SELECT * FROM customers; -- customer_id: CUST001001
SELECT * FROM products;  -- product_id: PROD002001
```

### Example 3: Year-Based Sequence Reset

```sql
-- Sequence for invoice numbers that resets each year
CREATE OR REPLACE FUNCTION get_yearly_invoice_number()
RETURNS VARCHAR(15) AS $$
DECLARE
    current_year INTEGER;
    seq_name TEXT;
    invoice_num INTEGER;
BEGIN
    current_year := EXTRACT(YEAR FROM CURRENT_DATE);
    seq_name := 'invoice_seq_' || current_year::TEXT;
    
    -- Create sequence for current year if it doesn't exist
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.sequences 
        WHERE sequence_name = seq_name
    ) THEN
        EXECUTE format('CREATE SEQUENCE %I START 1', seq_name);
    END IF;
    
    -- Get next value from year-specific sequence
    EXECUTE format('SELECT nextval(%L)', seq_name) INTO invoice_num;
    
    -- Return formatted invoice number
    RETURN current_year::TEXT || '-' || lpad(invoice_num::TEXT, 6, '0');
END;
$$ LANGUAGE plpgsql;

-- Create invoices table
CREATE TABLE invoices (
    id SERIAL PRIMARY KEY,
    invoice_number VARCHAR(15) DEFAULT get_yearly_invoice_number() UNIQUE,
    customer_id INTEGER,
    issue_date DATE DEFAULT CURRENT_DATE,
    amount DECIMAL(10,2)
);

-- Insert invoices
INSERT INTO invoices (customer_id, amount) 
VALUES (1, 1500.00), (2, 750.00);

-- View results
SELECT invoice_number, amount FROM invoices;
-- Results: 2025-000001, 2025-000002
```

### Example 4: Distributed Sequence (Multi-Server)

```sql
-- Create sequence with gaps for distributed systems
-- Server 1 uses values ending in 1 (1, 11, 21, 31, ...)
CREATE SEQUENCE server1_id_seq
    START WITH 1
    INCREMENT BY 10
    MINVALUE 1
    NO CYCLE;

-- Server 2 uses values ending in 2 (2, 12, 22, 32, ...)
CREATE SEQUENCE server2_id_seq
    START WITH 2
    INCREMENT BY 10
    MINVALUE 2
    NO CYCLE;

-- Function to get server-specific ID
CREATE OR REPLACE FUNCTION get_server_id(server_num INTEGER)
RETURNS BIGINT AS $$
BEGIN
    IF server_num = 1 THEN
        RETURN nextval('server1_id_seq');
    ELSIF server_num = 2 THEN
        RETURN nextval('server2_id_seq');
    ELSE
        RAISE EXCEPTION 'Invalid server number: %', server_num;
    END IF;
END;
$$ LANGUAGE plpgsql;

-- Usage
SELECT get_server_id(1); -- 1
SELECT get_server_id(2); -- 2
SELECT get_server_id(1); -- 11
SELECT get_server_id(2); -- 12
```

## Sequence Management

### Viewing Sequence Information

```sql
-- List all sequences
SELECT schemaname, sequencename, last_value, start_value, increment_by
FROM pg_sequences;

-- Detailed sequence information
SELECT 
    s.sequence_name,
    s.start_value,
    s.minimum_value,
    s.maximum_value,
    s.increment,
    s.cycle_option,
    s.cache_size,
    pg_get_serial_sequence(t.table_name, c.column_name) AS owned_by_table
FROM information_schema.sequences s
LEFT JOIN information_schema.columns c ON c.column_default LIKE '%' || s.sequence_name || '%'
LEFT JOIN information_schema.tables t ON c.table_name = t.table_name
WHERE s.sequence_schema = 'public';

-- Get current sequence values
SELECT 
    sequencename,
    last_value,
    is_called
FROM pg_sequences
WHERE schemaname = 'public';
```

### Modifying Sequences

```sql
-- Change sequence properties
ALTER SEQUENCE my_sequence
    RESTART WITH 1000       -- Reset to start at 1000
    INCREMENT BY 5          -- Change increment
    MAXVALUE 50000         -- Change max value
    CACHE 20;              -- Change cache size

-- Reset sequence to start value
ALTER SEQUENCE my_sequence RESTART;

-- Set sequence to specific value
SELECT setval('my_sequence', 5000);

-- Rename sequence
ALTER SEQUENCE old_seq_name RENAME TO new_seq_name;

-- Change owner
ALTER SEQUENCE my_sequence OWNER TO new_owner;

-- Move to different schema
ALTER SEQUENCE my_sequence SET SCHEMA new_schema;
```

### Sequence Synchronization

```sql
-- Sync sequence with existing table data
-- Useful after importing data or bulk inserts with explicit IDs

CREATE OR REPLACE FUNCTION sync_sequence_with_table(
    seq_name TEXT,
    table_name TEXT,
    column_name TEXT
)
RETURNS void AS $$
DECLARE
    max_value BIGINT;
BEGIN
    -- Get maximum value from table
    EXECUTE format('SELECT COALESCE(MAX(%I), 0) FROM %I', column_name, table_name)
    INTO max_value;
    
    -- Set sequence to max value + 1
    PERFORM setval(seq_name, max_value);
    
    RAISE NOTICE 'Sequence % synchronized with table %.% (max value: %)', 
                 seq_name, table_name, column_name, max_value;
END;
$$ LANGUAGE plpgsql;

-- Example usage after importing data
COPY customers FROM '/path/to/customers.csv' CSV HEADER;
SELECT sync_sequence_with_table('customer_id_seq', 'customers', 'id');
```

## Sequence Performance and Best Practices

### Performance Optimization

```sql
-- Use appropriate cache size for high-volume inserts
CREATE SEQUENCE high_volume_seq
    START WITH 1
    INCREMENT BY 1
    CACHE 1000;     -- Cache 1000 values to reduce disk I/O

-- Monitor sequence usage
CREATE VIEW sequence_usage AS
SELECT 
    schemaname,
    sequencename,
    last_value,
    start_value,
    increment_by,
    max_value,
    cache_value,
    log_cnt,
    is_cycled,
    is_called,
    -- Calculate percentage used
    CASE 
        WHEN max_value > 0 THEN 
            ROUND(((last_value::numeric - start_value) / (max_value::numeric - start_value)) * 100, 2)
        ELSE NULL 
    END AS percent_used
FROM pg_sequences;

-- Check for sequences nearing limits
SELECT * FROM sequence_usage WHERE percent_used > 90;
```

### Handling Sequence Gaps

```sql
-- Sequences can have gaps due to:
-- 1. Rolled-back transactions
-- 2. Server crashes
-- 3. Cached values not used

-- Example demonstrating gaps
CREATE SEQUENCE gap_demo_seq;

CREATE TABLE gap_demo (
    id INTEGER DEFAULT nextval('gap_demo_seq'),
    data TEXT
);

-- This creates a gap
BEGIN;
    INSERT INTO gap_demo (data) VALUES ('test1'); -- Uses sequence value 1
    INSERT INTO gap_demo (data) VALUES ('test2'); -- Uses sequence value 2
ROLLBACK; -- Transaction rolled back, but sequence values are "consumed"

-- Next insert will start at 3, creating a gap
INSERT INTO gap_demo (data) VALUES ('test3'); -- Uses sequence value 3

SELECT * FROM gap_demo; -- Only shows id=3, values 1 and 2 are missing
```

### Sequence Backup and Restore

```sql
-- Include sequences in backup scripts
-- pg_dump automatically includes sequences with tables

-- Manual sequence backup
CREATE TABLE sequence_backup AS
SELECT 
    schemaname,
    sequencename,
    last_value,
    start_value,
    increment_by,
    max_value,
    min_value,
    cache_value,
    log_cnt,
    is_cycled,
    is_called
FROM pg_sequences;

-- Restore sequence values
CREATE OR REPLACE FUNCTION restore_sequence_values()
RETURNS void AS $$
DECLARE
    rec RECORD;
BEGIN
    FOR rec IN SELECT * FROM sequence_backup LOOP
        PERFORM setval(
            quote_ident(rec.schemaname) || '.' || quote_ident(rec.sequencename),
            rec.last_value,
            rec.is_called
        );
        RAISE NOTICE 'Restored sequence %.%', rec.schemaname, rec.sequencename;
    END LOOP;
END;
$$ LANGUAGE plpgsql;
```

## Common Patterns and Use Cases

### 1. SERIAL vs IDENTITY vs Manual Sequences

```sql
-- SERIAL (traditional PostgreSQL)
CREATE TABLE users_serial (
    id SERIAL PRIMARY KEY,    -- Creates users_serial_id_seq
    username VARCHAR(50)
);

-- IDENTITY (SQL standard, PostgreSQL 10+)
CREATE TABLE users_identity (
    id INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    username VARCHAR(50)
);

-- Manual sequence (most flexible)
CREATE SEQUENCE users_manual_seq;
CREATE TABLE users_manual (
    id INTEGER DEFAULT nextval('users_manual_seq') PRIMARY KEY,
    username VARCHAR(50)
);
ALTER SEQUENCE users_manual_seq OWNED BY users_manual.id;

-- Comparison:
-- SERIAL: Simple, widely supported, creates sequence automatically
-- IDENTITY: SQL standard, better for migrations, more control
-- Manual: Maximum flexibility, custom naming, shared sequences
```

### 2. Shared Sequences Across Tables

```sql
-- Shared sequence for related entities
CREATE SEQUENCE global_id_seq START 1;

CREATE TABLE customers (
    id INTEGER DEFAULT nextval('global_id_seq') PRIMARY KEY,
    name VARCHAR(100)
);

CREATE TABLE vendors (
    id INTEGER DEFAULT nextval('global_id_seq') PRIMARY KEY,
    company_name VARCHAR(100)
);

-- Both tables share the same ID sequence, ensuring no conflicts
INSERT INTO customers (name) VALUES ('John Doe');      -- id = 1
INSERT INTO vendors (company_name) VALUES ('Acme');    -- id = 2
INSERT INTO customers (name) VALUES ('Jane Smith');    -- id = 3
```

### 3. Conditional Sequence Usage

```sql
-- Use sequence only when ID not provided
CREATE SEQUENCE conditional_seq;

CREATE TABLE flexible_ids (
    id INTEGER PRIMARY KEY,
    name VARCHAR(100)
);

-- Function to handle conditional ID assignment
CREATE OR REPLACE FUNCTION insert_with_optional_id(
    p_id INTEGER DEFAULT NULL,
    p_name VARCHAR(100)
)
RETURNS INTEGER AS $$
DECLARE
    new_id INTEGER;
BEGIN
    -- Use provided ID or generate from sequence
    new_id := COALESCE(p_id, nextval('conditional_seq'));
    
    INSERT INTO flexible_ids (id, name) VALUES (new_id, p_name);
    
    RETURN new_id;
END;
$$ LANGUAGE plpgsql;

-- Usage
SELECT insert_with_optional_id(NULL, 'Auto ID');     -- Uses sequence
SELECT insert_with_optional_id(1000, 'Manual ID');   -- Uses provided ID
```

## Troubleshooting Common Issues

### 1. Sequence Out of Sync

```sql
-- Problem: Manual inserts cause sequence to be behind
INSERT INTO products (id, name) VALUES (5000, 'Special Product');

-- Next sequence value might conflict
INSERT INTO products (name) VALUES ('Regular Product'); 
-- ERROR: duplicate key value violates unique constraint

-- Solution: Sync sequence
SELECT setval('products_id_seq', (SELECT MAX(id) FROM products));
```

### 2. Dropped Sequence

```sql
-- Problem: Sequence accidentally dropped
DROP SEQUENCE product_id_seq; -- Oops!

-- Solution: Recreate and sync
CREATE SEQUENCE product_id_seq;
SELECT setval('product_id_seq', (SELECT COALESCE(MAX(id), 0) FROM products));
ALTER SEQUENCE product_id_seq OWNED BY products.id;

-- Fix default value if needed
ALTER TABLE products ALTER COLUMN id SET DEFAULT nextval('product_id_seq');
```

### 3. Permission Issues

```sql
-- Grant sequence usage permissions
GRANT USAGE, SELECT ON SEQUENCE my_sequence TO app_user;
GRANT UPDATE ON SEQUENCE my_sequence TO app_user; -- For setval()

-- Grant permissions on all sequences in schema
GRANT USAGE, SELECT, UPDATE ON ALL SEQUENCES IN SCHEMA public TO app_user;
```

## Summary

Sequences in PostgreSQL are:
- **Atomic number generators** for unique identifiers
- **Thread-safe** and handle concurrent access automatically
- **Customizable** with start, increment, min/max values, caching, and cycling
- **Commonly used** with SERIAL columns and IDENTITY columns
- **Manageable** with functions like nextval(), currval(), setval()
- **Essential** for primary keys, order numbers, and unique identifiers

Key functions:
- `nextval()` - Get next value
- `currval()` - Get current value (session-specific)
- `setval()` - Set sequence to specific value
- `lastval()` - Get last value from any sequence in session

Sequences provide a reliable way to generate unique numbers in multi-user database environments.