# 98. How do you create and use sequences?

## Creating Sequences

### Basic Sequence Creation

```sql
-- Simple sequence with default settings
CREATE SEQUENCE my_sequence;

-- Sequence starts at 1, increments by 1
-- Min value: 1, Max value: 9223372036854775807 (for BIGINT)
-- No cycling, cache size: 1
```

### Sequence with Custom Parameters

```sql
-- Full syntax with all options
CREATE SEQUENCE order_id_seq
    AS INTEGER                    -- Data type: SMALLINT, INTEGER, BIGINT (default)
    START WITH 1000              -- Starting value (default: 1 for ascending, -1 for descending)
    INCREMENT BY 1               -- Step size (default: 1, can be negative)
    MINVALUE 1000               -- Minimum value (default: 1 for ascending)
    MAXVALUE 999999             -- Maximum value (default: large number based on type)
    CACHE 20                    -- Number of values to pre-allocate (default: 1)
    CYCLE                       -- Restart when min/max reached (default: NO CYCLE)
    OWNED BY orders.id;         -- Auto-drop when table/column is dropped

-- Alternative compact syntax
CREATE SEQUENCE product_seq START 5000 INCREMENT 10 CACHE 50;
```

### Sequence Data Types

```sql
-- Different data type examples
CREATE SEQUENCE small_seq AS SMALLINT START 1 MAXVALUE 32767;
CREATE SEQUENCE int_seq AS INTEGER START 1 MAXVALUE 2147483647;
CREATE SEQUENCE big_seq AS BIGINT START 1; -- Default, largest range

-- Check sequence properties
SELECT 
    sequence_name,
    data_type,
    start_value,
    minimum_value,
    maximum_value,
    increment,
    cycle_option
FROM information_schema.sequences
WHERE sequence_schema = 'public';
```

## Using Sequences

### Core Sequence Functions

```sql
-- Create a test sequence
CREATE SEQUENCE demo_seq START 100 INCREMENT 5;

-- nextval() - Get next value (advances sequence)
SELECT nextval('demo_seq'); -- Returns 100
SELECT nextval('demo_seq'); -- Returns 105
SELECT nextval('demo_seq'); -- Returns 110

-- currval() - Get current value from this session
SELECT currval('demo_seq'); -- Returns 110 (last value from current session)

-- lastval() - Get last value from ANY sequence in this session
SELECT lastval(); -- Returns 110

-- Get sequence info without advancing
SELECT last_value, is_called FROM demo_seq;
-- last_value: 110, is_called: true

-- setval() - Set sequence to specific value
SELECT setval('demo_seq', 500); -- Next nextval() will return 505
SELECT setval('demo_seq', 600, false); -- Next nextval() will return 600

-- Reset sequence to start value
ALTER SEQUENCE demo_seq RESTART;
SELECT nextval('demo_seq'); -- Returns 100 (start value)
```

### Integration with Tables

#### Method 1: SERIAL Columns (Traditional)

```sql
-- SERIAL automatically creates a sequence
CREATE TABLE customers (
    id SERIAL PRIMARY KEY,           -- Creates customers_id_seq
    name VARCHAR(100) NOT NULL,
    email VARCHAR(100) UNIQUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- View the auto-created sequence
SELECT pg_get_serial_sequence('customers', 'id'); -- Returns 'public.customers_id_seq'

-- Insert data (ID auto-generated)
INSERT INTO customers (name, email) 
VALUES 
    ('John Doe', 'john@example.com'),
    ('Jane Smith', 'jane@example.com');

SELECT * FROM customers;
-- Results:
-- id |    name    |      email       |         created_at
-- 1  | John Doe   | john@example.com | 2025-01-15 10:30:00
-- 2  | Jane Smith | jane@example.com | 2025-01-15 10:30:01
```

#### Method 2: IDENTITY Columns (SQL Standard, PostgreSQL 10+)

```sql
-- IDENTITY columns - SQL standard approach
CREATE TABLE products (
    id INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    name VARCHAR(200) NOT NULL,
    price DECIMAL(10,2),
    category VARCHAR(100)
);

-- Or with custom options
CREATE TABLE orders (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY (
        START WITH 1000
        INCREMENT BY 1
        MINVALUE 1000
        MAXVALUE 999999
        CACHE 10
    ) PRIMARY KEY,
    customer_id INTEGER REFERENCES customers(id),
    order_date DATE DEFAULT CURRENT_DATE,
    total_amount DECIMAL(10,2)
);

-- Insert data
INSERT INTO products (name, price, category) 
VALUES 
    ('Laptop', 999.99, 'Electronics'),
    ('Mouse', 29.99, 'Electronics');

INSERT INTO orders (customer_id, total_amount)
VALUES (1, 999.99), (2, 29.99);

-- View results
SELECT * FROM products;
SELECT * FROM orders; -- IDs start at 1000
```

#### Method 3: Manual Sequence Usage

```sql
-- Create sequence manually for maximum control
CREATE SEQUENCE invoice_number_seq
    START WITH 10001
    INCREMENT BY 1
    CACHE 25;

CREATE TABLE invoices (
    id INTEGER DEFAULT nextval('invoice_number_seq') PRIMARY KEY,
    invoice_number VARCHAR(20) DEFAULT 'INV-' || lpad(currval('invoice_number_seq')::TEXT, 8, '0'),
    customer_id INTEGER,
    amount DECIMAL(10,2),
    issue_date DATE DEFAULT CURRENT_DATE
);

-- Make sequence owned by column (auto-cleanup)
ALTER SEQUENCE invoice_number_seq OWNED BY invoices.id;

-- Better approach with custom function
CREATE OR REPLACE FUNCTION generate_invoice_number() 
RETURNS VARCHAR(20) AS $$
BEGIN
    RETURN 'INV-' || lpad(nextval('invoice_number_seq')::TEXT, 8, '0');
END;
$$ LANGUAGE plpgsql;

-- Update table to use function
ALTER TABLE invoices ALTER COLUMN invoice_number SET DEFAULT generate_invoice_number();

-- Insert data
INSERT INTO invoices (customer_id, amount) 
VALUES (1, 1500.00), (2, 750.00);

SELECT id, invoice_number, customer_id, amount FROM invoices;
-- Results:
-- id |  invoice_number  | customer_id | amount
-- 1  | INV-00000001     |           1 | 1500.00
-- 2  | INV-00000002     |           2 |  750.00
```

## Advanced Usage Patterns

### 1. Shared Sequences Across Tables

```sql
-- Global ID sequence for multiple entity types
CREATE SEQUENCE global_entity_id START 1;

CREATE TABLE users (
    id INTEGER DEFAULT nextval('global_entity_id') PRIMARY KEY,
    username VARCHAR(50) UNIQUE,
    email VARCHAR(100)
);

CREATE TABLE groups (
    id INTEGER DEFAULT nextval('global_entity_id') PRIMARY KEY,
    name VARCHAR(100),
    description TEXT
);

-- All entities get unique IDs from same sequence
INSERT INTO users (username, email) VALUES ('john_doe', 'john@example.com');
INSERT INTO groups (name, description) VALUES ('Admins', 'Administrator group');
INSERT INTO users (username, email) VALUES ('jane_smith', 'jane@example.com');

-- Results show sequential IDs across different tables
SELECT 'users' as table_name, id, username as name FROM users
UNION ALL
SELECT 'groups' as table_name, id, name FROM groups
ORDER BY id;
-- table_name | id | name
-- users      |  1 | john_doe
-- groups     |  2 | Admins
-- users      |  3 | jane_smith
```

### 2. Year-Based Sequence Reset

```sql
-- Sequence that resets annually for document numbering
CREATE OR REPLACE FUNCTION get_annual_document_number(doc_type TEXT)
RETURNS VARCHAR(20) AS $$
DECLARE
    current_year INTEGER;
    seq_name TEXT;
    doc_number INTEGER;
BEGIN
    current_year := EXTRACT(YEAR FROM CURRENT_DATE);
    seq_name := doc_type || '_seq_' || current_year::TEXT;
    
    -- Create sequence for current year if doesn't exist
    IF NOT EXISTS (
        SELECT 1 FROM pg_class 
        WHERE relname = seq_name AND relkind = 'S'
    ) THEN
        EXECUTE format('CREATE SEQUENCE %I START 1', seq_name);
    END IF;
    
    -- Get next value
    EXECUTE format('SELECT nextval(%L)', seq_name) INTO doc_number;
    
    -- Return formatted number
    RETURN doc_type || '-' || current_year::TEXT || '-' || 
           lpad(doc_number::TEXT, 4, '0');
END;
$$ LANGUAGE plpgsql;

-- Usage
CREATE TABLE documents (
    id SERIAL PRIMARY KEY,
    doc_number VARCHAR(20) DEFAULT get_annual_document_number('DOC'),
    title VARCHAR(200),
    content TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

INSERT INTO documents (title, content) 
VALUES 
    ('Annual Report', 'Company annual report content'),
    ('Policy Update', 'New policy document');

SELECT doc_number, title FROM documents;
-- Results: DOC-2025-0001, DOC-2025-0002
```

### 3. Multi-Format ID Generation

```sql
-- Different ID formats for different entity types
CREATE SEQUENCE customer_id_seq START 1001;
CREATE SEQUENCE order_id_seq START 2001;
CREATE SEQUENCE product_id_seq START 3001;

-- Functions for formatted IDs
CREATE OR REPLACE FUNCTION new_customer_id() RETURNS VARCHAR(12) AS $$
BEGIN
    RETURN 'CUST-' || lpad(nextval('customer_id_seq')::TEXT, 7, '0');
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION new_order_id() RETURNS VARCHAR(12) AS $$
BEGIN
    RETURN 'ORD-' || lpad(nextval('order_id_seq')::TEXT, 8, '0');
END;
$$ LANGUAGE plpgsql;

-- Tables using formatted IDs
CREATE TABLE customers (
    customer_id VARCHAR(12) DEFAULT new_customer_id() PRIMARY KEY,
    company_name VARCHAR(200),
    contact_email VARCHAR(100)
);

CREATE TABLE orders (
    order_id VARCHAR(12) DEFAULT new_order_id() PRIMARY KEY,
    customer_id VARCHAR(12) REFERENCES customers(customer_id),
    order_date DATE DEFAULT CURRENT_DATE,
    status VARCHAR(20) DEFAULT 'pending'
);

-- Insert test data
INSERT INTO customers (company_name, contact_email) 
VALUES ('Acme Corp', 'orders@acme.com');

INSERT INTO orders (customer_id) 
VALUES ('CUST-0001001');

SELECT * FROM customers; -- customer_id: CUST-0001001
SELECT * FROM orders;    -- order_id: ORD-00002001
```

### 4. Conditional Sequence Usage

```sql
-- Use sequence only when ID not provided
CREATE SEQUENCE flexible_id_seq;

CREATE OR REPLACE FUNCTION insert_with_flexible_id(
    p_id INTEGER DEFAULT NULL,
    p_name VARCHAR(100)
) RETURNS INTEGER AS $$
DECLARE
    new_id INTEGER;
BEGIN
    -- Use provided ID or get from sequence
    new_id := COALESCE(p_id, nextval('flexible_id_seq'));
    
    INSERT INTO flexible_items (id, name) VALUES (new_id, p_name);
    
    -- Sync sequence if manual ID was higher
    IF p_id IS NOT NULL AND p_id >= currval('flexible_id_seq') THEN
        PERFORM setval('flexible_id_seq', p_id);
    END IF;
    
    RETURN new_id;
END;
$$ LANGUAGE plpgsql;

CREATE TABLE flexible_items (
    id INTEGER PRIMARY KEY,
    name VARCHAR(100)
);

-- Usage examples
SELECT insert_with_flexible_id(NULL, 'Auto ID Item');     -- Uses sequence
SELECT insert_with_flexible_id(1000, 'Manual ID Item');   -- Uses provided ID
SELECT insert_with_flexible_id(NULL, 'Another Auto ID');  -- Continues from 1000
```

### 5. Sequence Caching for High-Volume Inserts

```sql
-- High-performance sequence for bulk operations
CREATE SEQUENCE bulk_import_seq
    START WITH 1
    INCREMENT BY 1
    CACHE 10000;    -- Cache 10,000 values for performance

CREATE TABLE bulk_data (
    id BIGINT DEFAULT nextval('bulk_import_seq') PRIMARY KEY,
    data_value VARCHAR(100),
    import_batch INTEGER,
    processed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Bulk insert example
INSERT INTO bulk_data (data_value, import_batch)
SELECT 
    'Data item ' || generate_series,
    1
FROM generate_series(1, 50000);

-- Check sequence performance
SELECT 
    schemaname,
    sequencename,
    cache_value,
    last_value
FROM pg_sequences 
WHERE sequencename = 'bulk_import_seq';
```

## Sequence Management

### Viewing and Monitoring Sequences

```sql
-- List all sequences with their current state
SELECT 
    schemaname,
    sequencename,
    start_value,
    last_value,
    increment_by,
    max_value,
    cache_value,
    is_cycled,
    is_called
FROM pg_sequences;

-- Detailed sequence information including ownership
SELECT 
    s.sequence_name,
    s.data_type,
    s.start_value,
    s.increment,
    s.maximum_value,
    s.cycle_option,
    tc.table_name,
    tc.column_name
FROM information_schema.sequences s
LEFT JOIN information_schema.table_constraints tc 
    ON s.sequence_name = tc.constraint_name
WHERE s.sequence_schema = 'public'
ORDER BY s.sequence_name;

-- Find sequences approaching their maximum
WITH sequence_usage AS (
    SELECT 
        schemaname,
        sequencename,
        last_value,
        max_value,
        CASE 
            WHEN max_value > 0 THEN 
                ROUND(((last_value::NUMERIC / max_value::NUMERIC) * 100), 2)
            ELSE 0 
        END AS usage_percent
    FROM pg_sequences
    WHERE max_value > 0
)
SELECT * FROM sequence_usage 
WHERE usage_percent > 80
ORDER BY usage_percent DESC;
```

### Modifying Existing Sequences

```sql
-- Change sequence properties
ALTER SEQUENCE customer_id_seq
    RESTART WITH 5000        -- Reset to start at 5000
    INCREMENT BY 2           -- Change increment
    MAXVALUE 999999         -- Change maximum
    CACHE 50;               -- Change cache size

-- Rename sequence
ALTER SEQUENCE old_sequence_name RENAME TO new_sequence_name;

-- Change ownership
ALTER SEQUENCE my_sequence OWNED BY my_table.my_column;

-- Move to different schema
ALTER SEQUENCE my_sequence SET SCHEMA new_schema;

-- Grant permissions
GRANT USAGE, SELECT, UPDATE ON SEQUENCE my_sequence TO app_user;
```

### Sequence Synchronization

```sql
-- Sync sequence with existing table data
CREATE OR REPLACE FUNCTION sync_sequence(
    sequence_name TEXT,
    table_name TEXT,
    column_name TEXT
) RETURNS BIGINT AS $$
DECLARE
    max_val BIGINT;
    new_val BIGINT;
BEGIN
    -- Get maximum value from table
    EXECUTE format('SELECT COALESCE(MAX(%I), 0) FROM %I', column_name, table_name)
    INTO max_val;
    
    -- Set sequence to max + 1
    EXECUTE format('SELECT setval(%L, %L)', sequence_name, max_val + 1)
    INTO new_val;
    
    RAISE NOTICE 'Synchronized sequence % with table %.% (set to %)', 
                 sequence_name, table_name, column_name, new_val;
    
    RETURN new_val;
END;
$$ LANGUAGE plpgsql;

-- Usage after data import
SELECT sync_sequence('users_id_seq', 'users', 'id');
```

## Best Practices

### 1. Choosing the Right Approach

```sql
-- Use SERIAL for simple auto-incrementing primary keys
CREATE TABLE simple_table (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100)
);

-- Use IDENTITY for SQL standard compliance
CREATE TABLE standard_table (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR(100)
);

-- Use manual sequences for:
-- - Custom ID formats
-- - Shared sequences
-- - Special numbering schemes
-- - Complex business logic
```

### 2. Performance Considerations

```sql
-- Use appropriate cache size based on usage
CREATE SEQUENCE low_volume_seq CACHE 1;      -- Single-user or low volume
CREATE SEQUENCE medium_volume_seq CACHE 20;   -- Normal applications  
CREATE SEQUENCE high_volume_seq CACHE 1000;   -- High-volume batch processing

-- Monitor cache effectiveness
SELECT 
    sequencename,
    cache_value,
    -- Estimate cache hit ratio based on log_cnt
    CASE 
        WHEN log_cnt > 0 THEN 
            ROUND((cache_value::NUMERIC / log_cnt::NUMERIC) * 100, 2)
        ELSE NULL 
    END AS cache_efficiency_percent
FROM pg_sequences;
```

### 3. Error Handling

```sql
-- Handle sequence overflow gracefully
CREATE OR REPLACE FUNCTION safe_next_id(seq_name TEXT) 
RETURNS BIGINT AS $$
DECLARE
    next_val BIGINT;
    max_val BIGINT;
BEGIN
    -- Get sequence max value
    SELECT max_value INTO max_val 
    FROM pg_sequences 
    WHERE sequencename = seq_name;
    
    -- Try to get next value
    BEGIN
        SELECT nextval(seq_name) INTO next_val;
        
        -- Check if approaching limit (warn at 95%)
        IF next_val > (max_val * 0.95) THEN
            RAISE WARNING 'Sequence % is at % of maximum value %', 
                         seq_name, next_val, max_val;
        END IF;
        
        RETURN next_val;
        
    EXCEPTION 
        WHEN SQLSTATE '2200H' THEN  -- sequence_generator_limit_exceeded
            RAISE EXCEPTION 'Sequence % has reached its maximum value. Please reset or extend the sequence.', seq_name;
    END;
END;
$$ LANGUAGE plpgsql;

-- Usage
SELECT safe_next_id('my_sequence');
```

## Summary

PostgreSQL sequences provide robust, concurrent-safe number generation with these key features:

**Creation Options:**
- Data types: SMALLINT, INTEGER, BIGINT
- Customizable start, increment, min/max values
- Caching for performance
- Cycling behavior

**Usage Methods:**
- SERIAL columns (traditional PostgreSQL)
- IDENTITY columns (SQL standard)
- Manual sequences (maximum flexibility)

**Core Functions:**
- `nextval()` - Get next value
- `currval()` - Get current value (session-specific)  
- `setval()` - Set to specific value
- `lastval()` - Get last value from any sequence

**Advanced Features:**
- Shared sequences across tables
- Custom ID formatting
- Year-based resets
- Conditional usage
- High-performance caching

Sequences are essential for generating unique identifiers in concurrent database environments while providing flexibility for various numbering schemes.